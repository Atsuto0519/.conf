
/*
  lib/map.coffee
 */

(function() {
  var log,
    slice = [].slice;

  log = function() {
    var args;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return console.log.apply(console, ['markdown-scroll, map:'].concat(args));
  };

  module.exports = {
    setMap: function(getVis) {
      var addNodeToMap, bot, botRow, bufRow, firstNode, hgt, i, idx, idxMatch, j, k, l, len, len1, len2, line, match, matches, maxLen, node, nodeMatch, nodePtr, ref, ref1, ref2, ref3, ref4, ref5, ref6, start, target, text, timings, top, topRow, wlkr;
      if (getVis == null) {
        getVis = true;
      }
      start = Date.now();
      timings = {};
      if (getVis) {
        this.getVisTopHgtBot();
        timings['getVisTopHgtBot'] = Date.now() - start;
        start = Date.now();
      }
      this.nodes = [];
      wlkr = document.createTreeWalker(this.previewEle, NodeFilter.SHOW_TEXT, null, true);
      while ((node = wlkr.nextNode())) {
        text = node.textContent;
        if (!/\w+/.test(text)) {
          continue;
        }
        ref = this.getEleTopHgtBot(node.parentNode, false), top = ref[0], hgt = ref[1], bot = ref[2];
        this.nodes.push([top, bot, null, null, text, null]);
      }
      timings['tree walk'] = Date.now() - start;
      start = Date.now();
      nodePtr = 0;
      for (bufRow = i = 0, ref1 = this.editor.getLastBufferRow(); 0 <= ref1 ? i <= ref1 : i >= ref1; bufRow = 0 <= ref1 ? ++i : --i) {
        line = this.editor.lineTextForBufferRow(bufRow);
        if (!(matches = line.match(/[a-z0-9-\s]+/ig))) {
          continue;
        }
        maxLen = 0;
        target = null;
        for (j = 0, len = matches.length; j < len; j++) {
          match = matches[j];
          if (!(/\w+/.test(match))) {
            continue;
          }
          match = match.replace(/^\s+|\s+$/g, '');
          if (match.length > maxLen) {
            maxLen = match.length;
            target = match;
          }
        }
        if (target) {
          nodeMatch = null;
          ref2 = this.nodes.slice(nodePtr);
          for (idx = k = 0, len1 = ref2.length; k < len1; idx = ++k) {
            node = ref2[idx];
            if (node[4].includes(target)) {
              if (nodeMatch) {
                nodeMatch = 'dup';
                break;
              }
              nodeMatch = node;
              idxMatch = idx;
            }
          }
          if (!nodeMatch || nodeMatch === 'dup') {
            continue;
          }
          ref3 = this.editor.screenRangeForBufferRange([[bufRow, 0], [bufRow, 9e9]]), (ref4 = ref3.start, topRow = ref4.row), (ref5 = ref3.end, botRow = ref5.row);
          nodeMatch[2] = topRow;
          nodeMatch[3] = botRow;
          nodeMatch[5] = target;
          nodePtr = idxMatch;
        }
      }
      timings['node match'] = Date.now() - start;
      start = Date.now();
      this.map = [[0, 0, 0, 0]];
      this.lastTopPix = this.lastBotPix = this.lastTopRow = this.lastBotRow = 0;
      firstNode = true;
      addNodeToMap = (function(_this) {
        return function(node) {
          var botPix, topPix;
          topPix = node[0], botPix = node[1], topRow = node[2], botRow = node[3];
          if (topPix < _this.lastBotPix || topRow <= _this.lastBotRow) {
            _this.lastTopPix = Math.min(topPix, _this.lastTopPix);
            _this.lastBotPix = Math.max(botPix, _this.lastBotPix);
            _this.lastTopRow = Math.min(topRow, _this.lastTopRow);
            _this.lastBotRow = Math.max(botRow, _this.lastBotRow);
            _this.map[_this.map.length - 1] = [_this.lastTopPix, _this.lastBotPix, _this.lastTopRow, _this.lastBotRow];
          } else {
            if (firstNode) {
              _this.map[0][1] = topPix;
              _this.map[0][3] = Math.max(0, topRow - 1);
            }
            _this.map.push([_this.lastTopPix = topPix, _this.lastBotPix = botPix, _this.lastTopRow = topRow, _this.lastBotRow = botRow]);
          }
          return firstNode = false;
        };
      })(this);
      ref6 = this.nodes;
      for (l = 0, len2 = ref6.length; l < len2; l++) {
        node = ref6[l];
        if (node[2] !== null) {
          addNodeToMap(node);
        }
      }
      botRow = this.editor.getLastScreenRow();
      topRow = Math.min(botRow, this.lastBotRow + 1);
      addNodeToMap([this.lastBotPix, this.previewEle.scrollHeight, topRow, botRow]);
      return this.nodes = null;
    }
  };

}).call(this);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiL1VzZXJzL2hvdG1hbi8uYXRvbS9wYWNrYWdlcy9tYXJrZG93bi1zY3JvbGwtc3luYy9saWIvbWFwLmNvZmZlZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7Ozs7QUFBQTtBQUFBLE1BQUEsR0FBQTtJQUFBOztFQUlBLEdBQUEsR0FBTSxTQUFBO0FBQ0osUUFBQTtJQURLO1dBQ0wsT0FBTyxDQUFDLEdBQUcsQ0FBQyxLQUFaLENBQWtCLE9BQWxCLEVBQTJCLENBQUMsdUJBQUQsQ0FBeUIsQ0FBQyxNQUExQixDQUFpQyxJQUFqQyxDQUEzQjtFQURJOztFQUdOLE1BQU0sQ0FBQyxPQUFQLEdBRUU7SUFBQSxNQUFBLEVBQVEsU0FBQyxNQUFEO0FBQ04sVUFBQTs7UUFETyxTQUFTOztNQUNoQixLQUFBLEdBQVEsSUFBSSxDQUFDLEdBQUwsQ0FBQTtNQUNSLE9BQUEsR0FBVTtNQUVWLElBQUcsTUFBSDtRQUNFLElBQUMsQ0FBQSxlQUFELENBQUE7UUFDQSxPQUFRLENBQUEsaUJBQUEsQ0FBUixHQUE2QixJQUFJLENBQUMsR0FBTCxDQUFBLENBQUEsR0FBYTtRQUFPLEtBQUEsR0FBUSxJQUFJLENBQUMsR0FBTCxDQUFBLEVBRjNEOztNQUlBLElBQUMsQ0FBQSxLQUFELEdBQVM7TUFDVCxJQUFBLEdBQU8sUUFBUSxDQUFDLGdCQUFULENBQTBCLElBQUMsQ0FBQSxVQUEzQixFQUF1QyxVQUFVLENBQUMsU0FBbEQsRUFBNkQsSUFBN0QsRUFBbUUsSUFBbkU7QUFDUCxhQUFNLENBQUMsSUFBQSxHQUFPLElBQUksQ0FBQyxRQUFMLENBQUEsQ0FBUixDQUFOO1FBQ0UsSUFBQSxHQUFPLElBQUksQ0FBQztRQUNaLElBQUcsQ0FBSSxLQUFLLENBQUMsSUFBTixDQUFXLElBQVgsQ0FBUDtBQUE0QixtQkFBNUI7O1FBQ0EsTUFBa0IsSUFBQyxDQUFBLGVBQUQsQ0FBaUIsSUFBSSxDQUFDLFVBQXRCLEVBQWtDLEtBQWxD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eEMsRUFBZ0QsTUFBaEQsQ0FBYjthQUVBLElBQUMsQ0FBQSxLQUFELEdBQVM7SUE3RUgsQ0FBUjs7QUFURiIsInNvdXJjZXNDb250ZW50IjpbIiMjI1xuICBsaWIvbWFwLmNvZmZlZVxuIyMjXG5cbmxvZyA9IChhcmdzLi4uKSAtPiBcbiAgY29uc29sZS5sb2cuYXBwbHkgY29uc29sZSwgWydtYXJrZG93bi1zY3JvbGwsIG1hcDonXS5jb25jYXQgYXJnc1xuXG5tb2R1bGUuZXhwb3J0cyA9XG5cbiAgc2V0TWFwOiAoZ2V0VmlzID0geWVzKSAtPlxuICAgIHN0YXJ0ID0gRGF0ZS5ub3coKVxuICAgIHRpbWluZ3MgPSB7fVxuICAgIFxuICAgIGlmIGdldFZpcyBcbiAgICAgIEBnZXRWaXNUb3BIZ3RCb3QoKVxuICAgICAgdGltaW5nc1snZ2V0VmlzVG9wSGd0Qm90J10gPSBEYXRlLm5vdygpIC0gc3RhcnQ7IHN0YXJ0ID0gRGF0ZS5ub3coKVxuICAgXG4gICAgQG5vZGVzID0gW11cbiAgICB3bGtyID0gZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlciBAcHJldmlld0VsZSwgTm9kZUZpbHRlci5TSE9XX1RFWFQsIG51bGwsIHllc1xuICAgIHdoaWxlIChub2RlID0gd2xrci5uZXh0Tm9kZSgpKVxuICAgICAgdGV4dCA9IG5vZGUudGV4dENvbnRlbnRcbiAgICAgIGlmIG5vdCAvXFx3Ky8udGVzdCB0ZXh0IHRoZW4gY29udGludWVcbiAgICAgIFt0b3AsIGhndCwgYm90XSA9IEBnZXRFbGVUb3BIZ3RCb3Qgbm9kZS5wYXJlbnROb2RlLCBub1xuICAgICAgQG5vZGVzLnB1c2ggW3RvcCwgYm90LCBudWxsLCBudWxsLCB0ZXh0LCBudWxsXVxuICAgICAgXG4gICAgdGltaW5nc1sndHJlZSB3YWxrJ10gPSBEYXRlLm5vdygpIC0gc3RhcnQ7IHN0YXJ0ID0gRGF0ZS5ub3coKVxuICAgIFxuICAgIG5vZGVQdHIgPSAwXG4gICAgZm9yIGJ1ZlJvdyBpbiBbMC4uQGVkaXRvci5nZXRMYXN0QnVmZmVyUm93KCldXG4gICAgICBsaW5lID0gQGVkaXRvci5saW5lVGV4dEZvckJ1ZmZlclJvdyBidWZSb3dcbiAgICAgIGlmIG5vdCAobWF0Y2hlcyA9IGxpbmUubWF0Y2ggL1thLXowLTktXFxzXSsvaWcpIHRoZW4gY29udGludWVcbiAgICAgIG1heExlbiA9IDBcbiAgICAgIHRhcmdldCA9IG51bGxcbiAgICAgIGZvciBtYXRjaCBpbiBtYXRjaGVzIHdoZW4gL1xcdysvLnRlc3QgbWF0Y2hcbiAgICAgICAgbWF0Y2ggPSBtYXRjaC5yZXBsYWNlIC9eXFxzK3xcXHMrJC9nLCAnJ1xuICAgICAgICBpZiBtYXRjaC5sZW5ndGggPiBtYXhMZW5cbiAgICAgICAgICBtYXhMZW4gPSBtYXRjaC5sZW5ndGhcbiAgICAgICAgICB0YXJnZXQgPSBtYXRjaFxuICAgICAgaWYgdGFyZ2V0XG4gICAgICAgIG5vZGVNYXRjaCA9IG51bGxcbiAgICAgICAgZm9yIG5vZGUsIGlkeCBpbiBAbm9kZXNbbm9kZVB0ci4uLl1cbiAgICAgICAgICBpZiBub2RlWzRdLmluY2x1ZGVzIHRhcmdldFxuICAgICAgICAgICAgaWYgbm9kZU1hdGNoIHRoZW4gbm9kZU1hdGNoID0gJ2R1cCc7IGJyZWFrXG4gICAgICAgICAgICBub2RlTWF0Y2ggPSBub2RlXG4gICAgICAgICAgICBpZHhNYXRjaCA9IGlkeFxuICAgICAgICBpZiBub3Qgbm9kZU1hdGNoIG9yIG5vZGVNYXRjaCBpcyAnZHVwJyB0aGVuIGNvbnRpbnVlXG4gICAgICAgIHtzdGFydDp7cm93OnRvcFJvd30sZW5kOntyb3c6Ym90Um93fX0gPVxuICAgICAgICAgIEBlZGl0b3Iuc2NyZWVuUmFuZ2VGb3JCdWZmZXJSYW5nZSBbW2J1ZlJvdywgMF0sW2J1ZlJvdywgOWU5XV1cbiAgICAgICAgbm9kZU1hdGNoWzJdID0gdG9wUm93XG4gICAgICAgIG5vZGVNYXRjaFszXSA9IGJvdFJvd1xuICAgICAgICBub2RlTWF0Y2hbNV0gPSB0YXJnZXQgICMgREVCVUdcbiAgICAgICAgbm9kZVB0ciA9IGlkeE1hdGNoXG4gICAgICAgIFxuICAgIHRpbWluZ3NbJ25vZGUgbWF0Y2gnXSA9IERhdGUubm93KCkgLSBzdGFydDsgc3RhcnQgPSBEYXRlLm5vdygpXG4gICAgXG4gICAgQG1hcCA9IFtbMCwwLDAsMF1dXG4gICAgQGxhc3RUb3BQaXggPSBAbGFzdEJvdFBpeCA9IEBsYXN0VG9wUm93ID0gQGxhc3RCb3RSb3cgPSAwXG4gICAgZmlyc3ROb2RlID0geWVzXG4gICAgXG4gICAgYWRkTm9kZVRvTWFwID0gKG5vZGUpID0+XG4gICAgICBbdG9wUGl4LCBib3RQaXgsIHRvcFJvdywgYm90Um93XSA9IG5vZGVcbiAgICAgIGlmIHRvcFBpeCA8ICBAbGFzdEJvdFBpeCBvclxuICAgICAgICAgdG9wUm93IDw9IEBsYXN0Qm90Um93XG4gICAgICAgIEBsYXN0VG9wUGl4ID0gTWF0aC5taW4gdG9wUGl4LCBAbGFzdFRvcFBpeFxuICAgICAgICBAbGFzdEJvdFBpeCA9IE1hdGgubWF4IGJvdFBpeCwgQGxhc3RCb3RQaXhcbiAgICAgICAgQGxhc3RUb3BSb3cgPSBNYXRoLm1pbiB0b3BSb3csIEBsYXN0VG9wUm93XG4gICAgICAgIEBsYXN0Qm90Um93ID0gTWF0aC5tYXggYm90Um93LCBAbGFzdEJvdFJvd1xuICAgICAgICBAbWFwW0BtYXAubGVuZ3RoIC0gMV0gPSBcbiAgICAgICAgICBbQGxhc3RUb3BQaXgsIEBsYXN0Qm90UGl4LCBAbGFzdFRvcFJvdywgQGxhc3RCb3RSb3ddXG4gICAgICBlbHNlXG4gICAgICAgIGlmIGZpcnN0Tm9kZVxuICAgICAgICAgIEBtYXBbMF1bMV0gPSB0b3BQaXhcbiAgICAgICAgICBAbWFwWzBdWzNdID0gTWF0aC5tYXggMCwgdG9wUm93IC0gMVxuICAgICAgICBAbWFwLnB1c2ggW0BsYXN0VG9wUGl4ID0gdG9wUGl4LFxuICAgICAgICAgICAgICAgICAgIEBsYXN0Qm90UGl4ID0gYm90UGl4LCBcbiAgICAgICAgICAgICAgICAgICBAbGFzdFRvcFJvdyA9IHRvcFJvdywgXG4gICAgICAgICAgICAgICAgICAgQGxhc3RCb3RSb3cgPSBib3RSb3ddXG4gICAgICBmaXJzdE5vZGUgPSBub1xuICAgICAgXG4gICAgZm9yIG5vZGUgaW4gQG5vZGVzIHdoZW4gbm9kZVsyXSBpc250IG51bGxcbiAgICAgIGFkZE5vZGVUb01hcCBub2RlXG4gICAgXG4gICAgYm90Um93ID0gQGVkaXRvci5nZXRMYXN0U2NyZWVuUm93KClcbiAgICB0b3BSb3cgPSBNYXRoLm1pbiAgYm90Um93LCBAbGFzdEJvdFJvdyArIDFcbiAgICBhZGROb2RlVG9NYXAgW0BsYXN0Qm90UGl4LCBAcHJldmlld0VsZS5zY3JvbGxIZWlnaHQsIHRvcFJvdywgYm90Um93XVxuICAgIFxuICAgIEBub2RlcyA9IG51bGxcbiAgICAgIFxuICAgICMgdGltaW5nc1snbWFwIG1lcmdlJ10gPSBEYXRlLm5vdygpIC0gc3RhcnQ7IHN0YXJ0ID0gRGF0ZS5ub3coKVxuICAgICMgc3RyID0gJydcbiAgICAjIGZvciBrLCB2IG9mIHRpbWluZ3MgdGhlbiBzdHIgKz0gICcgICcgKyBrICsgJzogJyArIHZcbiAgICAjIGxvZyAndGltaW5ncycsIHN0clxuIl19
